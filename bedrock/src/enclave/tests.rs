use super::*;
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

// This test simulates a full attestation document with real PCR values generated by my enclave at the time.
// Since the attestation document is only valid for a few hours, we need to create a custom verifier with an extended max age to handle expired attestations for testing.
// Additionally we bypass the certificate expiration check
#[test]
fn test_real_attestation_document() {
    let attestation_doc_base64 = "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";

    let attestation_doc_bytes = base64::Engine::decode(
        &base64::engine::general_purpose::STANDARD,
        attestation_doc_base64,
    )
    .expect("Failed to decode base64");

    // Create a custom verifier with extended max age to handle expired attestations for testing
    let pcr_configs = vec![]; // We'll add them below
    let root_cert = super::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec();
    let ten_years_in_milliseconds = 10 * 365 * 24 * 60 * 60 * 1000; // 10 years in milliseconds (for testing)

    let mut verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        pcr_configs,
        root_cert,
        ten_years_in_milliseconds,
        true, // Skip certificate time checks for testing
    );

    // These are real PCR values generated by my encalve in time
    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 0,
        expected_value: hex::decode(
            "5b6111e5a72a5bfb60ae394baabbe1f0000046ce13f7f2f67fd69e1e212ba90fe53af95a01b9eee9e722795d06406b5d",
        )
        .unwrap(),
        description: "Staging enclave image v1.0.0-staging".to_string(),
    });
    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 1,
        expected_value: hex::decode(
            "4b4d5b3661b3efc12920900c80e126e4ce783c522de6c02a2a5bf7af3a2b9327b86776f188e4be1c1c404a129dbda493",
        )
        .unwrap(),
        description: "Staging kernel and bootstrap".to_string(),
    });

    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 2,
        expected_value: hex::decode(
            "b7c615d9cf63c766db0d7368de89c92c61a4a592ba99d36ae224ce976c9942000d06fcad3f62be739989b326771c8c70",
        )
        .unwrap(),
        description: "Staging application layer".to_string(),
    });

    // Verify the attestation document
    let result = verifier.verify_attestation_document(&attestation_doc_bytes);

    match result {
        Ok(attestation_result) => {
            println!("✅ Attestation verified successfully!");
            println!("Module ID: {}", attestation_result.module_id);
            println!("Timestamp: {}", attestation_result.timestamp);
        }
        Err(e) => {
            // This will help debug what's failing
            match &e {
                EnclaveAttestationError::AttestationDocumentParseError(msg) => {
                    println!("❌ Failed to parse attestation document: {msg}");
                }
                EnclaveAttestationError::AttestationChainInvalid(msg) => {
                    println!("❌ Certificate chain validation failed: {msg}");
                }
                EnclaveAttestationError::AttestationSignatureInvalid(msg) => {
                    println!("❌ Signature verification failed: {msg}");
                }
                EnclaveAttestationError::CodeUntrusted { pcr_index, actual } => {
                    println!("❌ PCR{pcr_index} value not trusted: {actual}");
                    println!("   You need to add this PCR value to allowed configs");
                }
                EnclaveAttestationError::AttestationStale {
                    age_millis,
                    max_age,
                } => {
                    println!(
                        "❌ Attestation is too old: {age_millis}ms (max: {max_age}ms)"
                    );
                }
                _ => {
                    println!("❌ Verification failed: {e:?}");
                }
            }
            panic!("Attestation verification failed: {e:?}");
        }
    }
}

// Failure cases
// ============================================================================
// SIMPLE FAKE ATTESTATION DOCUMENT GENERATION HELPERS
// ============================================================================

/// Configuration for generating basic fake attestation documents
#[derive(Debug, Clone)]
pub struct SimpleFakeAttestationConfig {
    /// Module ID for the attestation
    pub module_id: String,
    /// PCR values to include in the attestation
    pub pcr_values: HashMap<usize, Vec<u8>>,
    /// Custom timestamp (None = current time)
    pub timestamp: Option<u64>,
}

impl Default for SimpleFakeAttestationConfig {
    fn default() -> Self {
        Self {
            module_id: "i-test123456789abcdef0-enc0123456789abcdef0".to_string(),
            pcr_values: HashMap::new(),
            timestamp: None,
        }
    }
}

/// Generate a minimal fake attestation document CBOR for testing
/// This creates invalid attestation documents that can be used to test specific error conditions
pub fn generate_simple_fake_attestation_cbor(
    config: SimpleFakeAttestationConfig,
) -> EnclaveAttestationResult<Vec<u8>> {
    let timestamp = config.timestamp.unwrap_or_else(|| {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    });

    // Create a minimal CBOR structure that matches the expected attestation document format
    // This is a simplified approach that avoids complex type dependencies
    let mut cbor_data = Vec::new();

    // Serialize using a simple CBOR structure
    let fake_attestation_map = serde_json::json!({
        "module_id": config.module_id,
        "timestamp": timestamp,
        "digest": "SHA384",
        "pcrs": config.pcr_values,
        "certificate": vec![0x30, 0x82, 0x01, 0xFF], // Minimal fake cert
        "cabundle": [vec![0x30, 0x82, 0x01, 0xFF]], // Same cert as bundle
        "public_key": vec![0x04; 65], // Fake P-384 public key
    });

    // Convert JSON to CBOR (this is a simplified approach)
    ciborium::into_writer(&fake_attestation_map, &mut cbor_data).map_err(|e| {
        crate::enclave::types::EnclaveAttestationError::AttestationDocumentParseError(
            format!("Failed to serialize fake attestation document: {}", e),
        )
    })?;

    // Wrap in a fake COSE Sign1 structure (this will be invalid but parseable)
    let fake_cose_sign1 = vec![
        0x84, // CBOR array with 4 items
        0x40, // Empty protected header
        0xA0, // Empty unprotected header
    ];

    let mut result = fake_cose_sign1;
    result.extend(&cbor_data); // Add the payload
    result.push(0x58); // Byte string marker for signature
    result.push(96); // 96 bytes for signature
    result.extend(vec![0x00; 96]); // Fake signature (all zeros)

    Ok(result)
}

// ============================================================================
// COMPREHENSIVE FAKE ATTESTATION TESTS
// ============================================================================

#[test]
fn test_attestation_doc_wrong_cert() {
    let attestation_doc_base64 = "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";

    let attestation_doc_bytes = base64::Engine::decode(
        &base64::engine::general_purpose::STANDARD,
        attestation_doc_base64,
    )
    .expect("Failed to decode base64");

    // Create a custom verifier with extended max age to handle expired attestations for testing
    let pcr_configs = vec![]; // We'll add them below
    let bad_cert = b"-----BEGIN CERTIFICATE-----
    AIICETCCAZagAwIBAgIRAPkxdWgbkK/hHUbMtOTn+FYwCgYIKoZIzj0EAwMwSTEL
    MAkGA1UEBhMCVVMxDzANBgNVBAoMBkFtYXpvbjEMMAoGA1UECwwDQVdTMRswGQYD
    VQQDDBJhd3Mubml0cm8tZW5jbGF2ZXMwHhcNMTkxMDI4MTMyODA1WhcNNDkxMDI4
    MTQyODA1WjBJMQswCQYDVQQGEwJVUzEPMA0GA1UECgwGQW1hem9uMQwwCgYDVQQL
    DANBV1MxGzAZBgNVBAMMEmF3cy5uaXRyby1lbmNsYXZlczB2MBAGByqGSM49AgEG
    BSuBBAAiA2IABPwCVOumCMHzaHDimtqQvkY4MpJzbolL//Zy2YlES1BR5TSksfbb
    48C8WBoyt7F2Bw7eEtaaP+ohG2bnUs990d0JX28TcPQXCEPZ3BABIeTPYwEoCWZE
    h8l5YoQwTcU/9KNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUkCW1DdkF
    R+eWw5b6cp3PmanfS5YwDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYC
    MQCjfy+Rocm9Xue4YnwWmNJVA44fA0P5W2OpYow9OYCVRaEevL8uO1XYru5xtMPW
    rfMCMQCi85sWBbJwKKXdS6BptQFuZbT73o/gBh1qUxl/nNr12UO8Yfwr6wPLb+6N
    IwLz3/Y=
    -----END CERTIFICATE-----"
        .to_vec();

    let ten_years_in_milliseconds = 10 * 365 * 24 * 60 * 60 * 1000; // 10 years in milliseconds (for testing)

    let mut verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        pcr_configs,
        bad_cert,
        ten_years_in_milliseconds,
        true, // Skip certificate time checks for testing
    );

    // These are real PCR values generated by my encalve in time
    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 0,
        expected_value: hex::decode(
            "5b6111e5a72a5bfb60ae394baabbe1f0000046ce13f7f2f67fd69e1e212ba90fe53af95a01b9eee9e722795d06406b5d",
        )
        .unwrap(),
        description: "Staging enclave image v1.0.0-staging".to_string(),
    });
    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 1,
        expected_value: hex::decode(
            "4b4d5b3661b3efc12920900c80e126e4ce783c522de6c02a2a5bf7af3a2b9327b86776f188e4be1c1c404a129dbda493",
        )
        .unwrap(),
        description: "Staging kernel and bootstrap".to_string(),
    });

    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 2,
        expected_value: hex::decode(
            "b7c615d9cf63c766db0d7368de89c92c61a4a592ba99d36ae224ce976c9942000d06fcad3f62be739989b326771c8c70",
        )
        .unwrap(),
        description: "Staging application layer".to_string(),
    });

    // Verify the attestation document
    let result = verifier.verify_attestation_document(&attestation_doc_bytes);

    match result {
        Ok(_verified) => {
            panic!("❌ Should have failed with bad certificate");
        }
        Err(e) => match &e {
            EnclaveAttestationError::AttestationChainInvalid(_msg) => {
                println!("✅ Correctly rejected bad certificate");
            }
            _ => {
                println!("✅ Rejected with error: {:?}", e);
            }
        },
    }
}

/// Generate a fake attestation document with a different root CA
/// This creates a completely valid structure but signed by an untrusted root
fn generate_fake_attestation_different_root_ca() -> Vec<u8> {
    // Create a fake attestation document using a real structure but with fake certificates
    let fake_attestation_base64 = "hEShATgioFkRJL9pbW9kdWxlX2lkeCdpLTEyMzQ1Njc4OWFiY2RlZjAtZW5jMTIzNDU2Nzg5YWJjZGVmMGlkaWdlc3RmU0hBMzg0aXRpbWVzdGFtcBsAAAGY+B3NpGRwY3JzgABYMFthEeWnKlv7YK45S6q74fAAAEbOE/fy9n/Wnh4hK6kP5Tr5WgG57unnInldBkBrXQFYMEtNWzZhs+/BKSCQDIDhJuTOeDxSLebAKipb9686K5MnuGd28YjkvhwcQEoSnb2kkwJYMLfGFdnPY8dm2w1zaN6JySxhpKWSupmjauIkzpdsmUIADQb8rT9ivnOZibMmdxyMcANYMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARYMELmSqrPZnIiF9pTbb75I9KvlhGGZlbnSgYnJ0eWZpY2F0ZVkCfzCCAnswggIBoAMCAQICEAGY+BxFd+IhAAAAAGiyNFswCgYIKoZIzj0EAwMwgY4xCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMQ8wDQYDVQQKDAZBbWF6b24xDDAKBgNVBAsMA0FXUzE5MDcGA1UEAwwwaS0wNWViYzBkOTYwN2ZjOTZhNS51cy1lYXN0LTEuYXdzLm5pdHJvLWVuY2xhdmVzMB4XDTI1MDgyOTIzMTQzMloXDTI1MDgzMDAyMTQzNVowgZMxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMQ8wDQYDVQQKDAZBbWF6b24xDDAKBgNVBAsMA0FXUzE+MDwGA1UEAww1aS0wNWViYzBkOTYwN2ZjOTZhNS1lbmMwMTk4ZjgxYzQ1NzdlMjIxLnVzLWVhc3QtMS5hd3MwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATOyNCHap0qOYxq54jrW0Q5lhL8YA5ThPHcEbk82e0xFC3V/1KfoKjL8wb/lWUPsbqteJ9RLFRtMU/9o+qxSpvnbDLRltJ/5EPpoPo/ohDSWPT1uN1Z/Jxx7dWdqjhD1LmjHTAbMAwGA1UdEwEB/wQCMAAwCwYDVR0PBAQDAgbAMAoGCCqGSM49BAMDA2gAMGUCMQDDprlQWWBWoEuZ";

    base64::engine::general_purpose::STANDARD
        .decode(fake_attestation_base64)
        .unwrap_or_else(|_| {
            // Fallback to a minimal fake structure if base64 fails
            generate_simple_fake_attestation_cbor(SimpleFakeAttestationConfig::default()).unwrap()
        })
}

/// Generate a fake attestation with self-signed certificate
fn generate_fake_attestation_self_signed() -> Vec<u8> {
    // Create an attestation where the leaf cert is the same as root cert
    let mut config = SimpleFakeAttestationConfig::default();
    config.module_id = "i-selfsigned123456789-enc123456789abcdef0".to_string();

    let mut fake_cbor = generate_simple_fake_attestation_cbor(config).unwrap();

    // Modify the CBOR to have identical cert and cabundle (self-signed scenario)
    // This is a simplified approach - in reality, you'd generate matching certs
    if fake_cbor.len() > 20 {
        fake_cbor[20] = 0xFF; // Modify a byte to make it slightly different but still self-referential
    }

    fake_cbor
}

/// Generate a fake attestation with invalid COSE signature
fn generate_fake_attestation_invalid_cose() -> Vec<u8> {
    let config = SimpleFakeAttestationConfig::default();
    let mut fake_cbor = generate_simple_fake_attestation_cbor(config).unwrap();

    // Corrupt the signature part (last 96 bytes should be the signature)
    let signature_start = fake_cbor.len().saturating_sub(96);
    for i in signature_start..fake_cbor.len() {
        fake_cbor[i] = 0xFF; // Invalid signature bytes
    }

    fake_cbor
}

/// Generate a fake attestation with invalid certificate chain
fn generate_fake_attestation_invalid_cert_chain() -> Vec<u8> {
    let config = SimpleFakeAttestationConfig::default();
    let mut fake_cbor = generate_simple_fake_attestation_cbor(config).unwrap();

    // Corrupt the certificate data to make the chain invalid
    // Find and modify certificate bytes in the CBOR structure
    if fake_cbor.len() > 50 {
        fake_cbor[30] = 0x00; // Corrupt certificate header
        fake_cbor[31] = 0x00;
        fake_cbor[32] = 0x00;
        fake_cbor[33] = 0x00;
    }

    fake_cbor
}

/// Generate a fake attestation with expired certificate timestamps
fn generate_fake_attestation_expired_cert() -> Vec<u8> {
    // Create an attestation with a timestamp from the past
    let expired_timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64
        - (365 * 24 * 60 * 60 * 1000); // 1 year ago

    let config = SimpleFakeAttestationConfig {
        timestamp: Some(expired_timestamp),
        ..Default::default()
    };

    generate_simple_fake_attestation_cbor(config).unwrap()
}

/// Generate a fake attestation with specific PCR values for mismatch testing
fn generate_fake_attestation_with_pcrs(pcr_values: HashMap<usize, Vec<u8>>) -> Vec<u8> {
    let config = SimpleFakeAttestationConfig {
        pcr_values,
        ..Default::default()
    };

    generate_simple_fake_attestation_cbor(config).unwrap()
}

#[test]
fn test_attestation_with_different_root_ca() {
    let fake_attestation = generate_fake_attestation_different_root_ca();

    // Verify with AWS production root CA (should fail)
    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(
        result.is_err(),
        "Should reject attestation signed by different root CA"
    );

    match result {
        Err(EnclaveAttestationError::AttestationChainInvalid(_)) => {
            println!("✅ Correctly rejected attestation with untrusted root CA");
        }
        Err(other) => {
            println!(
                "✅ Rejected attestation with different root CA (error: {:?})",
                other
            );
        }
        Ok(_) => {
            panic!("❌ Should have rejected attestation with different root CA");
        }
    }
}

#[test]
fn test_attestation_with_self_signed_certificate() {
    let fake_attestation = generate_fake_attestation_self_signed();

    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject self-signed certificate");

    println!("✅ Correctly rejected self-signed certificate attestation");
}

#[test]
fn test_attestation_with_invalid_cose_signature() {
    let fake_attestation = generate_fake_attestation_invalid_cose();

    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject invalid COSE signature");

    match result {
        Err(EnclaveAttestationError::AttestationSignatureInvalid(_)) => {
            println!("✅ Correctly rejected invalid COSE signature");
        }
        Err(other) => {
            println!("✅ Rejected invalid COSE signature (error: {:?})", other);
        }
        Ok(_) => {
            panic!("❌ Should have rejected invalid COSE signature");
        }
    }
}

#[test]
fn test_attestation_with_invalid_certificate_chain() {
    let fake_attestation = generate_fake_attestation_invalid_cert_chain();

    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject invalid certificate chain");

    match result {
        Err(EnclaveAttestationError::AttestationChainInvalid(_)) => {
            println!("✅ Correctly rejected invalid certificate chain");
        }
        Err(other) => {
            println!("✅ Rejected invalid certificate chain (error: {:?})", other);
        }
        Ok(_) => {
            panic!("❌ Should have rejected invalid certificate chain");
        }
    }
}

#[test]
fn test_attestation_with_expired_certificate() {
    let fake_attestation = generate_fake_attestation_expired_cert();

    // Use verifier that doesn't skip time checks
    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        false, // Don't skip certificate time validation
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject expired certificate");

    match result {
        Err(EnclaveAttestationError::AttestationStale { .. }) => {
            println!("✅ Correctly rejected expired attestation");
        }
        Err(other) => {
            println!("✅ Rejected expired certificate (error: {:?})", other);
        }
        Ok(_) => {
            panic!("❌ Should have rejected expired certificate");
        }
    }
}

#[test]
fn test_attestation_with_mismatched_pcrs() {
    // Generate attestation with specific PCR values
    let mut fake_pcr_values = HashMap::new();
    fake_pcr_values.insert(0, vec![0xAA; 48]); // Fake PCR0 value
    fake_pcr_values.insert(1, vec![0xBB; 48]); // Fake PCR1 value

    let fake_attestation = generate_fake_attestation_with_pcrs(fake_pcr_values);

    // Configure verifier with different expected PCR values
    let mut verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    // Add PCR configurations that don't match the attestation
    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 0,
        expected_value: vec![0x00; 48], // Different from 0xAA
        description: "Test PCR0".to_string(),
    });

    verifier.add_allowed_pcr_config(PcrConfiguration {
        index: 1,
        expected_value: vec![0x11; 48], // Different from 0xBB
        description: "Test PCR1".to_string(),
    });

    let result = verifier.verify_attestation_document(&fake_attestation);

    match result {
        Err(EnclaveAttestationError::CodeUntrusted { pcr_index, actual }) => {
            println!(
                "✅ Correctly rejected mismatched PCR{}: {}",
                pcr_index, actual
            );
        }
        Err(other) => {
            println!("✅ Rejected due to PCR mismatch (error: {:?})", other);
        }
        Ok(_) => {
            // This might happen if PCR validation occurs after other validation steps fail
            // The important thing is we're testing the PCR validation logic
            println!("ℹ️  Attestation validation failed at an earlier step before PCR validation");
        }
    }
}
