use crypto_box::{PublicKey, SecretKey};

use super::*;
use base64::engine::general_purpose::STANDARD;
use base64::Engine;
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

// Helper function that provides a full attestation document with real PCR values generated by my enclave at the time.
// Since the attestation document is only valid for a few hours, we need to create a custom verifier with an extended max age to handle expired attestations for testing.
// Additionally we bypass the certificate expiration check to allow testing with expired documents.
fn get_real_attestation_document(
) -> (EnclaveAttestationVerifier, String, PublicKey, SecretKey) {
    let attestation_doc_base64 = "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";
    // This is a key pair that was generated with crypto_box (Curve25519)
    // Example code to generate a key pair:
    // `let secret_key = SecretKey::generate(&mut OsRng)`
    // `let public_key = secret_key.public_key()`
    let public_key_b64 = "Q7mGRhu9t1LdOJ6PNjEuXrwzd/keaU2BJdG8AHmy4SI=";
    let secret_key_b64 = "rLySe2CE1kOMxVXDmwYqQ0mh0WdiCBR3TNhIWDvgaec=";

    let public_key = {
        let public_key_bytes = STANDARD
            .decode(public_key_b64)
            .expect("Failed to decode public key");
        PublicKey::from_slice(&public_key_bytes).expect("Failed to decode public key")
    };

    let secret_key = {
        let secret_key_bytes = STANDARD
            .decode(secret_key_b64)
            .expect("Failed to decode secret key");
        SecretKey::from_slice(&secret_key_bytes).expect("Failed to decode secret key")
    };

    // Create a custom verifier with extended max age to handle expired attestations for testing
    let pcr_configs = vec![]; // We'll add them below
    let root_cert = super::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec();
    let ten_years_in_milliseconds = 10 * 365 * 24 * 60 * 60 * 1000; // 10 years in milliseconds (for testing)

    let mut verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        pcr_configs,
        root_cert,
        ten_years_in_milliseconds,
        true, // Skip certificate time checks for testing
    );

    // These are real PCR values generated by my enclave in time
    verifier.add_allowed_pcr_config(vec![
        PcrMeasurement::new(0, hex_literal::hex!("108b32466f5dc0a9971e0bc8e3e4074e7821bb2dcad3841bdec9a08b30f173386f0394a01486df181f316b39443dab34")),
        PcrMeasurement::new(1, hex_literal::hex!("4b4d5b3661b3efc12920900c80e126e4ce783c522de6c02a2a5bf7af3a2b9327b86776f188e4be1c1c404a129dbda493")),
        PcrMeasurement::new(2, hex_literal::hex!("08c6b2cba2d0c0ab63f3533cb44e092fb211775323cd62cd571f871e127ae1844f0e948a54ba58ecd29fbe03a64d5edc")),
        PcrMeasurement::new(8, hex_literal::hex!("b38251662033340b540c2d7e5f49e7ec6d10afcb5f17c72132e20a7f0a54576dc4d2c6ce062ed2ed2b6ae01815d69c8d"))
    ]);

    (
        verifier,
        attestation_doc_base64.to_string(),
        public_key,
        secret_key,
    )
}

// This tests verifies a real attestation document with real PCR values.
#[test]
fn test_real_attestation_document() {
    let (verifier, attestation_doc_base64, _, _) = get_real_attestation_document();

    let attestation_doc_bytes = STANDARD
        .decode(attestation_doc_base64)
        .expect("Failed to decode base64");

    // Verify the attestation document
    let result = verifier.verify_attestation_document(&attestation_doc_bytes);

    match result {
        Ok(_) => {}
        Err(e) => {
            // This will help debug what's failing
            match &e {
                EnclaveAttestationError::AttestationDocumentParseError(msg) => {
                    println!("❌ Failed to parse attestation document: {msg}");
                }
                EnclaveAttestationError::AttestationChainInvalid(msg) => {
                    println!("❌ Certificate chain validation failed: {msg}");
                }
                EnclaveAttestationError::AttestationSignatureInvalid(msg) => {
                    println!("❌ Signature verification failed: {msg}");
                }
                EnclaveAttestationError::CodeUntrusted { pcr_index, actual } => {
                    println!("❌ PCR{pcr_index} value not trusted: {actual}");
                    println!("   You need to add this PCR value to allowed configs");
                }
                EnclaveAttestationError::AttestationStale {
                    age_millis,
                    max_age,
                } => {
                    println!(
                        "❌ Attestation is too old: {age_millis}ms (max: {max_age}ms)"
                    );
                }
                _ => {
                    println!("❌ Verification failed: {e:?}");
                }
            }
            panic!("Attestation verification failed: {e:?}");
        }
    }
}

/// This tests verifies a real attestation document with real PCR values and encrypts a message using the enclave's public key.
/// It tests encryption is produced correctly by decrypting the ciphertext with the secret key generated inside the enclave.
#[test]
fn test_verify_attestation_document_and_encrypt() {
    let (verifier, attestation_doc_base64, public_key, secret_key) =
        get_real_attestation_document();

    let plaintext = b"Hello, world!";

    let result = verifier
        .verify_attestation_document_and_encrypt(&attestation_doc_base64, plaintext)
        .expect("attestation is valid");

    let public_key_base64 = STANDARD.encode(public_key);
    assert_eq!(
        result.verified_attestation.enclave_public_key,
        public_key_base64
    );

    let decrypted_ciphertext = secret_key
        .unseal(&result.ciphertext)
        .expect("decrypt error");
    assert_eq!(decrypted_ciphertext, plaintext);
}

// Failure cases
/// Configuration for generating basic fake attestation documents
#[derive(Debug, Clone)]
pub struct SimpleFakeAttestationConfig {
    /// Module ID for the attestation
    pub module_id: String,
    /// PCR values to include in the attestation
    pub pcr_values: HashMap<usize, Vec<u8>>,
    /// Custom timestamp (None = current time)
    pub timestamp: Option<u64>,
}

impl Default for SimpleFakeAttestationConfig {
    fn default() -> Self {
        Self {
            module_id: "i-test123456789abcdef0-enc0123456789abcdef0".to_string(),
            pcr_values: HashMap::new(),
            timestamp: None,
        }
    }
}

/// Generate a minimal fake attestation document CBOR for testing
/// This creates invalid attestation documents that can be used to test specific error conditions
pub fn generate_simple_fake_attestation_self_signed(
    config: &SimpleFakeAttestationConfig,
) -> EnclaveAttestationResult<Vec<u8>> {
    let timestamp = config.timestamp.unwrap_or_else(|| {
        u64::try_from(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_millis(),
        )
        .unwrap_or(u64::MAX)
    });

    // Create a minimal CBOR structure that matches the expected attestation document format
    // This is a simplified approach that avoids complex type dependencies
    let mut cbor_data = Vec::new();

    // Serialize using a simple CBOR structure
    let fake_attestation_map = serde_json::json!({
        "module_id": config.module_id,
        "timestamp": timestamp,
        "digest": "SHA384",
        "pcrs": config.pcr_values,
        "certificate": vec![0x30, 0x82, 0x01, 0xFF], // Minimal fake cert
        "cabundle": [vec![0x30, 0x82, 0x01, 0xFF]], // Same cert as bundle
        "public_key": vec![0x04; 65], // Fake P-384 public key
    });

    // Convert JSON to CBOR (this is a simplified approach)
    ciborium::into_writer(&fake_attestation_map, &mut cbor_data).map_err(|e| {
        crate::nitro_enclave::types::EnclaveAttestationError::AttestationDocumentParseError(
            format!("Failed to serialize fake attestation document: {e}"),
        )
    })?;

    // Wrap in a fake COSE Sign1 structure (this will be invalid but parseable)
    let fake_cose_sign1 = vec![
        0x84, // CBOR array with 4 items
        0x40, // Empty protected header
        0xA0, // Empty unprotected header
    ];

    let mut result = fake_cose_sign1;
    result.extend(&cbor_data); // Add the payload
    result.push(0x58); // Byte string marker for signature
    result.push(96); // 96 bytes for signature
    result.extend(vec![0x00; 96]); // Fake signature (all zeros)

    Ok(result)
}

/// Generate a fake attestation document with a different root CA
/// This creates a completely valid structure but signed by an untrusted root
fn generate_fake_attestation_different_root_ca() -> Vec<u8> {
    // Create a fake attestation document using a real structure but with fake certificates
    let fake_attestation_base64 = "hEShATgioFkRJL9pbW9kdWxlX2lkeCdpLTEyMzQ1Njc4OWFiY2RlZjAtZW5jMTIzNDU2Nzg5YWJjZGVmMGlkaWdlc3RmU0hBMzg0aXRpbWVzdGFtcBsAAAGY+B3NpGRwY3JzgABYMFthEeWnKlv7YK45S6q74fAAAEbOE/fy9n/Wnh4hK6kP5Tr5WgG57unnInldBkBrXQFYMEtNWzZhs+/BKSCQDIDhJuTOeDxSLebAKipb9686K5MnuGd28YjkvhwcQEoSnb2kkwJYMLfGFdnPY8dm2w1zaN6JySxhpKWSupmjauIkzpdsmUIADQb8rT9ivnOZibMmdxyMcANYMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARYMELmSqrPZnIiF9pTbb75I9KvlhGGZlbnSgYnJ0eWZpY2F0ZVkCfzCCAnswggIBoAMCAQICEAGY+BxFd+IhAAAAAGiyNFswCgYIKoZIzj0EAwMwgY4xCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMQ8wDQYDVQQKDAZBbWF6b24xDDAKBgNVBAsMA0FXUzE5MDcGA1UEAwwwaS0wNWViYzBkOTYwN2ZjOTZhNS51cy1lYXN0LTEuYXdzLm5pdHJvLWVuY2xhdmVzMB4XDTI1MDgyOTIzMTQzMloXDTI1MDgzMDAyMTQzNVowgZMxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMQ8wDQYDVQQKDAZBbWF6b24xDDAKBgNVBAsMA0FXUzE+MDwGA1UEAww1aS0wNWViYzBkOTYwN2ZjOTZhNS1lbmMwMTk4ZjgxYzQ1NzdlMjIxLnVzLWVhc3QtMS5hd3MwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATOyNCHap0qOYxq54jrW0Q5lhL8YA5ThPHcEbk82e0xFC3V/1KfoKjL8wb/lWUPsbqteJ9RLFRtMU/9o+qxSpvnbDLRltJ/5EPpoPo/ohDSWPT1uN1Z/Jxx7dWdqjhD1LmjHTAbMAwGA1UdEwEB/wQCMAAwCwYDVR0PBAQDAgbAMAoGCCqGSM49BAMDA2gAMGUCMQDDprlQWWBWoEuZ";

    base64::engine::general_purpose::STANDARD
        .decode(fake_attestation_base64)
        .unwrap_or_else(|_| {
            // Fallback to a minimal fake structure if base64 fails
            let cfg = SimpleFakeAttestationConfig::default();
            generate_simple_fake_attestation_self_signed(&cfg).unwrap()
        })
}

/// Generate a fake attestation with self-signed certificate
fn generate_fake_attestation_self_signed() -> Vec<u8> {
    let config = SimpleFakeAttestationConfig::default();
    generate_simple_fake_attestation_self_signed(&config).unwrap()
}

/// Generate a fake attestation with invalid COSE signature
fn generate_fake_attestation_invalid_cose() -> Vec<u8> {
    let config = SimpleFakeAttestationConfig::default();
    let mut fake_cbor = generate_simple_fake_attestation_self_signed(&config).unwrap();

    // Corrupt the signature part (last 96 bytes should be the signature)
    let signature_start = fake_cbor.len().saturating_sub(96);
    for byte in fake_cbor.iter_mut().skip(signature_start) {
        *byte = 0xFF; // Invalid signature bytes
    }

    fake_cbor
}

/// Generate a fake attestation with invalid certificate chain
fn generate_fake_attestation_invalid_cert_chain() -> Vec<u8> {
    let config = SimpleFakeAttestationConfig::default();
    let mut fake_cbor = generate_simple_fake_attestation_self_signed(&config).unwrap();

    // Corrupt the certificate data to make the chain invalid
    // Find and modify certificate bytes in the CBOR structure
    if fake_cbor.len() > 50 {
        fake_cbor[30] = 0x00; // Corrupt certificate header
        fake_cbor[31] = 0x00;
        fake_cbor[32] = 0x00;
        fake_cbor[33] = 0x00;
    }

    fake_cbor
}

/// Generate a fake attestation with expired certificate timestamps
fn generate_fake_attestation_expired_cert() -> Vec<u8> {
    // Create an attestation with a timestamp from the past
    let now_ms = u64::try_from(
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis(),
    )
    .unwrap_or(u64::MAX);
    let expired_timestamp = now_ms.saturating_sub(365 * 24 * 60 * 60 * 1000); // 1 year ago

    let config = SimpleFakeAttestationConfig {
        timestamp: Some(expired_timestamp),
        ..Default::default()
    };

    generate_simple_fake_attestation_self_signed(&config).unwrap()
}

/// Generate a fake attestation with specific PCR values for mismatch testing
fn generate_fake_attestation_with_pcrs(pcr_values: HashMap<usize, Vec<u8>>) -> Vec<u8> {
    let config = SimpleFakeAttestationConfig {
        pcr_values,
        ..Default::default()
    };
    generate_simple_fake_attestation_self_signed(&config).unwrap()
}

// ============================================================================
// COMPREHENSIVE FAKE ATTESTATION TESTS
// ============================================================================

#[test]
fn test_attestation_doc_wrong_cert() {
    let attestation_doc_base64 = "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";

    let attestation_doc_bytes = base64::Engine::decode(
        &base64::engine::general_purpose::STANDARD,
        attestation_doc_base64,
    )
    .expect("Failed to decode base64");

    // Create a custom verifier with extended max age to handle expired attestations for testing
    let pcr_configs = vec![]; // We'll add them below
    let bad_cert = b"-----BEGIN CERTIFICATE-----
    AIICETCCAZagAwIBAgIRAPkxdWgbkK/hHUbMtOTn+FYwCgYIKoZIzj0EAwMwSTEL
    MAkGA1UEBhMCVVMxDzANBgNVBAoMBkFtYXpvbjEMMAoGA1UECwwDQVdTMRswGQYD
    VQQDDBJhd3Mubml0cm8tZW5jbGF2ZXMwHhcNMTkxMDI4MTMyODA1WhcNNDkxMDI4
    MTQyODA1WjBJMQswCQYDVQQGEwJVUzEPMA0GA1UECgwGQW1hem9uMQwwCgYDVQQL
    DANBV1MxGzAZBgNVBAMMEmF3cy5uaXRyby1lbmNsYXZlczB2MBAGByqGSM49AgEG
    BSuBBAAiA2IABPwCVOumCMHzaHDimtqQvkY4MpJzbolL//Zy2YlES1BR5TSksfbb
    48C8WBoyt7F2Bw7eEtaaP+ohG2bnUs990d0JX28TcPQXCEPZ3BABIeTPYwEoCWZE
    h8l5YoQwTcU/9KNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUkCW1DdkF
    R+eWw5b6cp3PmanfS5YwDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYC
    MQCjfy+Rocm9Xue4YnwWmNJVA44fA0P5W2OpYow9OYCVRaEevL8uO1XYru5xtMPW
    rfMCMQCi85sWBbJwKKXdS6BptQFuZbT73o/gBh1qUxl/nNr12UO8Yfwr6wPLb+6N
    IwLz3/Y=
    -----END CERTIFICATE-----"
        .to_vec();

    let ten_years_in_milliseconds = 10 * 365 * 24 * 60 * 60 * 1000; // 10 years in milliseconds (for testing)

    let mut verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        pcr_configs,
        bad_cert,
        ten_years_in_milliseconds,
        true, // Skip certificate time checks for testing
    );

    // These are real PCR values generated by my enclave in time
    verifier.add_allowed_pcr_config(vec![
        PcrMeasurement::new(0, hex_literal::hex!("5b6111e5a72a5bfb60ae394baabbe1f0000046ce13f7f2f67fd69e1e212ba90fe53af95a01b9eee9e722795d06406b5d")),
        PcrMeasurement::new(1, hex_literal::hex!("4b4d5b3661b3efc12920900c80e126e4ce783c522de6c02a2a5bf7af3a2b9327b86776f188e4be1c1c404a129dbda493")),
        PcrMeasurement::new(2, hex_literal::hex!("b7c615d9cf63c766db0d7368de89c92c61a4a592ba99d36ae224ce976c9942000d06fcad3f62be739989b326771c8c70")),
    ]);

    // Verify the attestation document
    let result = verifier.verify_attestation_document(&attestation_doc_bytes);

    match result {
        Ok(_verified) => {
            panic!("❌ Should have failed with bad certificate");
        }
        Err(e) => match &e {
            EnclaveAttestationError::AttestationChainInvalid(_msg) => {
                println!("✅ Correctly rejected bad certificate");
            }
            _ => {
                println!("✅ Rejected with error: {e:?}");
            }
        },
    }
}

#[test]
fn test_attestation_with_different_root_ca() {
    let fake_attestation = generate_fake_attestation_different_root_ca();

    // Verify with AWS production root CA (should fail)
    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::nitro_enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(
        result.is_err(),
        "Should reject attestation signed by different root CA"
    );

    match result {
        Err(EnclaveAttestationError::AttestationChainInvalid(_)) => {
            println!("✅ Correctly rejected attestation with untrusted root CA");
        }
        Err(other) => {
            println!(
                "✅ Rejected attestation with different root CA (error: {other:?})",
            );
        }
        Ok(_) => {
            panic!("❌ Should have rejected attestation with different root CA");
        }
    }
}

#[test]
fn test_attestation_with_self_signed_certificate() {
    let fake_attestation = generate_fake_attestation_self_signed();

    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::nitro_enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject self-signed certificate");

    println!("✅ Correctly rejected self-signed certificate attestation");
}

#[test]
fn test_attestation_with_invalid_cose_signature() {
    let fake_attestation = generate_fake_attestation_invalid_cose();

    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::nitro_enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject invalid COSE signature");

    match result {
        Err(EnclaveAttestationError::AttestationSignatureInvalid(_)) => {
            println!("✅ Correctly rejected invalid COSE signature");
        }
        Err(other) => {
            println!("✅ Rejected invalid COSE signature (error: {other:?})");
        }
        Ok(_) => {
            panic!("❌ Should have rejected invalid COSE signature");
        }
    }
}

#[test]
fn test_attestation_with_invalid_certificate_chain() {
    let fake_attestation = generate_fake_attestation_invalid_cert_chain();

    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::nitro_enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject invalid certificate chain");

    match result {
        Err(EnclaveAttestationError::AttestationChainInvalid(_)) => {
            println!("✅ Correctly rejected invalid certificate chain");
        }
        Err(other) => {
            println!("✅ Rejected invalid certificate chain (error: {other:?})");
        }
        Ok(_) => {
            panic!("❌ Should have rejected invalid certificate chain");
        }
    }
}

#[test]
fn test_attestation_with_expired_certificate() {
    let fake_attestation = generate_fake_attestation_expired_cert();

    // Use verifier that doesn't skip time checks
    let verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::nitro_enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        false, // Don't skip certificate time validation
    );

    let result = verifier.verify_attestation_document(&fake_attestation);
    assert!(result.is_err(), "Should reject expired certificate");

    match result {
        Err(EnclaveAttestationError::AttestationStale { .. }) => {
            println!("✅ Correctly rejected expired attestation");
        }
        Err(other) => {
            println!("✅ Rejected expired certificate (error: {other:?})");
        }
        Ok(_) => {
            panic!("❌ Should have rejected expired certificate");
        }
    }
}

#[test]
fn test_attestation_with_mismatched_pcrs() {
    // Generate attestation with specific PCR values
    let mut fake_pcr_values = HashMap::new();
    fake_pcr_values.insert(0, vec![0xAA; 48]); // Fake PCR0 value
    fake_pcr_values.insert(1, vec![0xBB; 48]); // Fake PCR1 value

    let fake_attestation = generate_fake_attestation_with_pcrs(fake_pcr_values);

    // Configure verifier with different expected PCR values
    let mut verifier = EnclaveAttestationVerifier::new_with_config_and_time_skip(
        vec![],
        crate::nitro_enclave::constants::AWS_NITRO_ROOT_CERT_PROD.to_vec(),
        60000,
        true,
    );

    // Add PCR configurations that don't match the attestation
    verifier.add_allowed_pcr_config(vec![
        PcrMeasurement::new(0, vec![0x00; 48]), // Different from 0xAA
        PcrMeasurement::new(1, vec![0x11; 48]), // Different from 0xBB
    ]);

    let result = verifier.verify_attestation_document(&fake_attestation);

    match result {
        Err(EnclaveAttestationError::CodeUntrusted { pcr_index, actual }) => {
            println!("✅ Correctly rejected mismatched PCR{pcr_index}: {actual}");
        }
        Err(other) => {
            println!("✅ Rejected due to PCR mismatch (error: {other:?})");
        }
        Ok(_) => {
            // This might happen if PCR validation occurs after other validation steps fail
            // The important thing is we're testing the PCR validation logic
            println!("ℹ️  Attestation validation failed at an earlier step before PCR validation");
        }
    }
}

#[test]
fn test_multiple_pcr_configurations_success() {
    // This test verifies that PCR validation succeeds when ANY configuration matches,
    // not requiring ALL configurations to match. This enables support for multiple
    // enclave versions with different PCR values.

    let (mut verifier, attestation_doc_base64, _, _) = get_real_attestation_document();

    // Clear existing configurations
    verifier.allowed_pcr_configs.clear();

    // Add the correct PCR configuration (from the real attestation)
    let correct_config = vec![
        PcrMeasurement::new(0, hex_literal::hex!("108b32466f5dc0a9971e0bc8e3e4074e7821bb2dcad3841bdec9a08b30f173386f0394a01486df181f316b39443dab34")),
        PcrMeasurement::new(1, hex_literal::hex!("4b4d5b3661b3efc12920900c80e126e4ce783c522de6c02a2a5bf7af3a2b9327b86776f188e4be1c1c404a129dbda493")),
        PcrMeasurement::new(2, hex_literal::hex!("08c6b2cba2d0c0ab63f3533cb44e092fb211775323cd62cd571f871e127ae1844f0e948a54ba58ecd29fbe03a64d5edc")),
        PcrMeasurement::new(8, hex_literal::hex!("b38251662033340b540c2d7e5f49e7ec6d10afcb5f17c72132e20a7f0a54576dc4d2c6ce062ed2ed2b6ae01815d69c8d"))
    ];

    // Add a completely different configuration (simulating a different enclave version)
    // Each PCR value must be exactly 48 bytes (96 hex characters) for SHA-384
    let different_config = vec![
        PcrMeasurement::new(0, hex_literal::hex!("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),
        PcrMeasurement::new(1, hex_literal::hex!("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")),
        PcrMeasurement::new(2, hex_literal::hex!("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd")),
        PcrMeasurement::new(8, hex_literal::hex!("cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"))
    ];

    // Add both configurations - the attestation should succeed because ONE matches
    verifier.allowed_pcr_configs.push(different_config.clone());
    verifier.allowed_pcr_configs.push(correct_config);

    let attestation_doc_bytes = STANDARD
        .decode(attestation_doc_base64)
        .expect("Failed to decode base64");

    // Verify the attestation document
    let result = verifier.verify_attestation_document(&attestation_doc_bytes);

    // This should SUCCEED because one configuration matches
    match result {
        Ok(_) => {
            println!("✅ Successfully validated attestation with one matching configuration out of multiple");
        }
        Err(e) => {
            panic!("❌ Failed to validate attestation even though one configuration matches: {e:?}");
        }
    }

    // Now test with ONLY non-matching configurations - should fail
    verifier.allowed_pcr_configs.clear();
    verifier.allowed_pcr_configs.push(different_config);

    let another_different_config = vec![
        PcrMeasurement::new(0, hex_literal::hex!("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")),
        PcrMeasurement::new(1, hex_literal::hex!("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb")),
        PcrMeasurement::new(2, hex_literal::hex!("111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111")),
        PcrMeasurement::new(8, hex_literal::hex!("222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222"))
    ];
    verifier.allowed_pcr_configs.push(another_different_config);

    let result = verifier.verify_attestation_document(&attestation_doc_bytes);

    // This should FAIL because no configuration matches
    match result {
        Err(EnclaveAttestationError::CodeUntrusted { .. }) => {
            println!("✅ Correctly rejected attestation when no configuration matches");
        }
        Ok(_) => {
            panic!(
                "❌ Should have failed validation when no PCR configuration matches"
            );
        }
        Err(e) => {
            panic!("❌ Unexpected error type: {e:?}");
        }
    }
}
