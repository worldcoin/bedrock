//! A helper to construct 4337 UserOperation nonces.
//!
//! Layout (24-byte nonceKey + 8-byte sequence):
//! [0..=4]    : magic: currently "bdrck" or "pbhtx" (5 bytes) -- this is used to identify transactions generated by Bedrock
//! [5]        : typeId (1 byte)
//! [6]        : instruction flags (1 byte)
//! [7..=16]   : metadata (10 bytes) - type-specific metadata
//! [17..=23]  : random tail (7 bytes)
//! [24..=32]  : sequence (8 bytes) - usually 0 for Bedrock crafted txs

use ruint::aliases::U256;

use crate::primitives::BEDROCK_NONCE_PREFIX_CONST;

/// Stable, never-reordered identifiers for transaction classes.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum TransactionTypeId {
    /// ERC-20 transfer
    Transfer = 1,
    /// `WorldGiftManager` gift
    WorldGiftManagerGift = 127,
    /// `WorldGiftManager` redeem
    WorldGiftManagerRedeem = 128,
    /// `WorldGiftManager` cancel
    WorldGiftManagerCancel = 129,
    /// `WorldCampaignManager` sponsor
    WorldCampaignManagerSponsor = 130,
    /// `WorldCampaignManager` claim
    WorldCampaignManagerClaim = 131,
}

impl TransactionTypeId {
    /// Returns the numeric id for this transaction type.
    #[inline]
    #[must_use]
    pub const fn as_u8(self) -> u8 {
        self as u8
    }
}

/// Instruction flags carried in the nonceKey.
/// Bit 0: Default flag.
/// Bits 1â€“7: reserved.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum InstructionFlag {
    /// Default flag. No special instructions.
    Default = 0,
}

/// Constructs a nonceKey for a 4337 `UserOperation`.
///
/// A 4337 nonce is a 256-bit integer where the high 192 bits are used for the `nonceKey`
/// and the low 64 bits are used for the sequence. This struct models the 24-byte `nonceKey`
/// only. The sequence is provided separately at encoding time.
///
/// The `nonceKey` is defined for Bedrock in an opinionated way (in the spirit of RIP-7712)
/// to encompass metadata required for rendering transactions for users.
///
/// Follows 4337 specs: <https://eips.ethereum.org/EIPS/eip-4337#semi-abstracted-nonce-support>
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct NonceKeyV1 {
    /// Stable transaction class id.
    pub type_id: TransactionTypeId,
    /// Instruction flags bitfield.
    pub instruction: InstructionFlag,
    /// Type-specific metadata for indexers (10 bytes).
    pub metadata: [u8; 10],
    /// Random tail to reduce accidental collisions (7 bytes, 56 bits).
    pub random_tail: [u8; 7],
    /// Sequence number for the operation. This is currently not in use and set to 0 for all operations.
    pub sequence: u64,
}

impl NonceKeyV1 {
    /// Builds a new v1 nonceKey with a random 7-byte tail.
    #[must_use]
    pub fn new(
        type_id: TransactionTypeId,
        instruction: InstructionFlag,
        metadata: [u8; 10],
    ) -> Self {
        // Generate 7 bytes of entropy using a random u64 and dropping the MSB.
        let rand_u64: u64 = rand::random();
        let bytes = rand_u64.to_be_bytes();
        let mut tail = [0u8; 7];
        tail.copy_from_slice(&bytes[1..8]);
        Self {
            type_id,
            instruction,
            metadata,
            random_tail: tail,
            sequence: 0,
        }
    }

    /// Test/advanced constructor allowing explicit random tail specification.
    #[must_use]
    pub const fn with_random_tail(
        type_id: TransactionTypeId,
        instruction: InstructionFlag,
        metadata: [u8; 10],
        random_tail: [u8; 7],
    ) -> Self {
        Self {
            type_id,
            instruction,
            metadata,
            random_tail,
            sequence: 0,
        }
    }

    /// Serialize into the 24-byte nonceKey v1 layout.
    #[must_use]
    fn as_bytes(&self) -> [u8; 24] {
        let mut out: [u8; 24] = [0u8; 24];
        // [0..=4] magic
        out[0..=4].copy_from_slice(BEDROCK_NONCE_PREFIX_CONST);
        // [5] typeId
        out[5] = self.type_id.as_u8();
        // [6] instruction flags
        out[6] = self.instruction as u8;
        // [7..=16] metadata (10 bytes)
        out[7..=16].copy_from_slice(&self.metadata);
        // [17..=23] random tail (7 bytes)
        out[17..=23].copy_from_slice(&self.random_tail);
        out
    }

    /// Encodes the 24-byte nonceKey together with a provided 8-byte sequence into a U256 integer
    /// for use with the 4337 `EntryPoint` contract.
    #[must_use]
    pub fn encode_with_sequence(&self, sequence: u64) -> U256 {
        let mut be = [0u8; 32];
        be[..24].copy_from_slice(&self.as_bytes());
        be[24..].copy_from_slice(&sequence.to_be_bytes());
        U256::from_be_bytes(be)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_nonce_key_layout() {
        let metadata = [0x11u8; 10];
        let random_tail = [0x22u8; 7];
        let key = NonceKeyV1::with_random_tail(
            TransactionTypeId::Transfer,
            InstructionFlag::Default,
            metadata,
            random_tail,
        );
        let bytes = key.as_bytes();

        // magic
        assert_eq!(&bytes[0..=4], &[0x62, 0x64, 0x72, 0x63, 0x6b]);
        // typeId
        assert_eq!(bytes[5], TransactionTypeId::Transfer.as_u8());
        // instruction
        assert_eq!(bytes[6], 0);
        // metadata
        assert_eq!(&bytes[7..=16], &metadata);
        // random tail
        assert_eq!(&bytes[17..=23], &random_tail);
    }

    #[test]
    fn test_encode_nonce_sequence_is_zero() {
        let key = NonceKeyV1::with_random_tail(
            TransactionTypeId::Transfer,
            InstructionFlag::Default,
            [0u8; 10],
            [0u8; 7],
        );
        let nonce = key.encode_with_sequence(0);
        let lower_64 = nonce & U256::from(u64::MAX);
        assert!(lower_64.is_zero(), "sequence must be zero"); // checks the lower 64 bits of the nonce (i.e. the sequence) are zero
    }
}
